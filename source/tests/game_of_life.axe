def print_grid(grid: i32[height][width], width: i32, height: i32) {
    mut val y: i32 = 0;
    loop {
        if y >= height {
            break;
        }
        
        mut val x: i32 = 0;
        loop {
            if x >= width {
                break;
            }
            
            if grid[y][x] == 1 {
                print "â– ";
            } else {
                print "â–¡";
            }
            
            x = x + 1;
        }
        
        println "";
        y = y + 1;
    }
}

def count_neighbors(grid: i32[height][width], x: i32, y: i32, width: i32, height: i32): i32 {
    mut val count: i32 = 0;
    
    // Check all 8 neighbors
    mut val dy: i32 = -1;
    loop {
        if dy > 1 {
            break;
        }
        
        mut val dx: i32 = -1;
        loop {
            if dx > 1 {
                break;
            }
            
            if dx == 0 and dy == 0 {
                dx = dx + 1;
                continue;
            }
            
            mut val nx: i32 = x + dx;
            mut val ny: i32 = y + dy;
            
            // Check boundaries
            if nx >= 0 and nx < width and ny >= 0 and ny < height {
                count = count + grid[ny][nx];
            }
            
            dx = dx + 1;
        }
        
        dy = dy + 1;
    }
    
    return count;
}

def next_generation(grid: i32[height][width], new_grid: i32[height][width], width: i32, height: i32) {
    mut val y: i32 = 0;
    loop {
        if y >= height {
            break;
        }
        
        mut val x: i32 = 0;
        loop {
            if x >= width {
                break;
            }
            
            mut val neighbors: i32 = count_neighbors(grid, x, y, width, height);
            
            if grid[y][x] == 1 {
                // Live cell rules
                if neighbors == 2 or neighbors == 3 {
                    new_grid[y][x] = 1;
                } else {
                    new_grid[y][x] = 0;
                }
            } else {
                // Dead cell rules
                if neighbors == 3 {
                    new_grid[y][x] = 1;
                } else {
                    new_grid[y][x] = 0;
                }
            }
            
            x = x + 1;
        }
        
        y = y + 1;
    }
}

def copy_grid(src: i32[height][width], dst: i32[height][width], width: i32, height: i32) {
    mut val y: i32 = 0;
    loop {
        if y >= height {
            break;
        }
        
        mut val x: i32 = 0;
        loop {
            if x >= width {
                break;
            }
            
            dst[y][x] = src[y][x];
            x = x + 1;
        }
        
        y = y + 1;
    }
}

main {
    // Grid dimensions
    val width: i32 = 10;
    val height: i32 = 10;
    
    // Create two grids for double buffering
    mut val grid: i32[10][10];
    mut val new_grid: i32[10][10];
    
    // Initialize with a glider pattern
    grid[1][2] = 1;
    grid[2][3] = 1;
    grid[3][1] = 1;
    grid[3][2] = 1;
    grid[3][3] = 1;
    
    mut val generation: i32 = 0;
    
    loop {
        print "Generation ";
        println generation;
        println "";
        
        print_grid(grid, width, height);
        
        // Calculate next generation
        next_generation(grid, new_grid, width, height);
        
        // Copy new grid back to main grid
        copy_grid(new_grid, grid, width, height);
        
        generation = generation + 1;
        
        // Run for 20 generations
        if generation >= 20 {
            break;
        }
        
        println "";
        println "---";
        println "";
    }
}
